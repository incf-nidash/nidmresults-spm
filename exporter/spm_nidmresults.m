function [nidmfile, prov] = spm_nidmresults(nidm_json, direc)
% Export SPM stats results using the Neuroimaging Data Model (NIDM)
% FORMAT [nidmfile, prov] = spm_results_nidm(nidm_json)
% nidm_json- json structure containing NIDM details
% direc    - root directory for image files
%
% nidmfile - output NIDM zip archive filename
% prov     - provenance object (see spm_provenance.m)
%__________________________________________________________________________
% References:
% 
% Neuroimaging Data Model (NIDM):
%   http://nidm.nidash.org/
%
% PROV-DM: The PROV Data Model:
%   http://www.w3.org/TR/prov-dm/
%__________________________________________________________________________
% Copyright (C) 2013-2016 Wellcome Trust Centre for Neuroimaging

% Guillaume Flandin, Camille Maumet
% $Id: spm_results_nidm.m 6903 2016-10-12 11:36:41Z guillaume $

%-Options
%==========================================================================

%-General options
%--------------------------------------------------------------------------
gz           = '.gz';                        %-Compressed NIfTI {'.gz', ''}

% jsonwrite('nidm.json', nidm_json, struct('indent','    ', 'escape', false));

%==========================================================================
%-Populate output directory
%==========================================================================
if ~exist(direc,'dir'), direc = pwd; end
outdir       = tempname(direc);
sts          = mkdir(outdir);
if ~sts, error('Cannot create directory "%s".',outdir); end

%-Design Matrix image (as png and csv)
%--------------------------------------------------------------------------
DesMtxValue = nidm_json('DesignMatrix_value');
reg_names = nidm_json('DesignMatrix_regressorNames');

files.desimg = fullfile(outdir,'DesignMatrix.png');

xX.nKX       = spm_DesMtx('sca',DesMtxValue,reg_names);
DesMtx       = (xX.nKX + 1)*32;
ml           = floor(size(DesMtx,1)/size(DesMtx,2));
DesMtx       = reshape(repmat(DesMtx,ml,1),size(DesMtx,1),[]);
imwrite(DesMtx,gray(64),files.desimg,'png');
files.descsv = fullfile(outdir,'DesignMatrix.csv');
csvwrite(files.descsv,DesMtxValue);

%-Maximum Intensity Projection image (as png)
%--------------------------------------------------------------------------
if isKey(nidm_json, 'Inferences')
    con_name = nidm_json('Inferences').keys;
    con_name = con_name(1);

    inferences = nidm_json('Inferences');
    if inferences.Count>1
        warning('Exporter assumes only one inference is reported.')
    end
    
    inference = inferences(con_name{1});
else
    inferences = nidm_json('ConjunctionInferences');
    
    if inferences.Count>1
        warning('Exporter assumes only one inference is reported.')
    end
    
    con_descs = inferences.keys;
    
    inference = inferences(con_descs{1});
    
    con_name = inference('nidm_contrastName');
end

if isKey(inference, 'ExcursionSetMap_hasMaximumIntensityProjection')
    has_mip = true;
    files.mip_orig = inference('ExcursionSetMap_hasMaximumIntensityProjection');
    files.mip = fullfile(outdir, files.mip_orig);
    copyfile(files.mip_orig, files.mip)
else
    has_mip = false;
end

%-Beta images (as NIfTI)
%--------------------------------------------------------------------------
files.beta_orig = nidm_json('ParameterEstimateMaps');
regressor_names = files.beta_orig.keys;
for i=1:numel(regressor_names)
    files.beta{i} = fullfile(outdir,[sprintf('ParameterEstimate_%04d',i) '.nii' gz]);
    img2nii(files.beta_orig(regressor_names{i}), files.beta{i});
end

%-SPM{.}, contrast, contrast standard error, and contrast explained mean square images (as NIfTI)
%--------------------------------------------------------------------------
contrasts = nidm_json('Contrasts');
% con = contrasts(con_name);
contrast_names = keys(contrasts);

for i=1:numel(contrast_names)
    con = contrasts(contrast_names{i});
    
    if numel(contrast_names) == 1, postfix = '';
    else                    postfix = sprintf('_%04d',i); end
    stat_type = con('StatisticMap_statisticType');
    
    if strcmp(contrast_names{i},con_name{1})
        STAT = stat_type;
    end
    
    if isKey(con, 'StatisticMap_statisticNotation')
        stat = con('StatisticMap_statisticNotation');
    else
        if strcmp(stat_type, 'obo_tstatistic')
            stat = 'T';
        elseif strcmp(stat_type, 'obo_Fstatistic')
            stat = 'F';
        else
            warning('nidm:unknownStatType', ...
                ['Unrecognised statistic type.'])
            stat = 'U';
        end
    end
    
    files.spm{i}  = fullfile(outdir,[stat 'Statistic' postfix '.nii' gz]);
    stat_map{i} = con('StatisticMap_atLocation');
    dof = con('StatisticMap_errorDegreesOfFreedom');
    if stat == 'T'
        info = struct('STAT', 'T', ...
                  'STATstr', ['T_{' num2str(dof) '}'], ...
                  'df', [NaN dof]);
    elseif stat == 'F'
        info = struct('STAT', 'F', ...
                      'STATstr', ['F_{' num2str(dof) '}'], ...
                      'df', dof);
    else
        info = struct('STAT', stat);
    end
    img2nii(fullfile(pwd, stat_map{i}), files.spm{i}, info);
    
    if stat == 'T'
        files.con{i} = fullfile(outdir,['Contrast' postfix '.nii' gz]);
        files.con_orig{i} = con('ContrastMap_atLocation');
        dof = con('StatisticMap_errorDegreesOfFreedom');
        info = struct('STAT', 'con');
        img2nii(files.con_orig{i}, files.con{i}, info);
        
        files.conse{i} = fullfile(outdir,['ContrastStandardError' postfix '.nii' gz]);
        files.conse_orig{i} = con('ContrastStandardErrorMap_atLocation');
        img2nii(files.conse_orig{i}, files.conse{i});
    elseif stat == 'F'
        files.effms{i} = fullfile(outdir,['ContrastExplainedMeanSquare' postfix '.nii' gz]);
        files.effms_orig{i} = con('ContrastExplainedMeanSquareMap_atLocation');
        img2nii(files.effms_orig{i}, files.effms{i});
    else
        
    end
end

%-Thresholded SPM{.} image (as NIfTI)
%--------------------------------------------------------------------------
files.tspm = fullfile(outdir,['ExcursionSet.nii' gz]);
excset_map = inference('ExcursionSetMap_atLocation');
img2nii(excset_map, files.tspm);

%-Residual Mean Squares image (as NIfTI)
%--------------------------------------------------------------------------
files.rms = fullfile(outdir,['ResidualMeanSquares.nii' gz]);
files.rms_orig = nidm_json('ResidualMeanSquaresMap_atLocation');
img2nii(files.rms_orig, files.rms);

%-Resels per Voxel image (as NIfTI)
%--------------------------------------------------------------------------
has_rpv = false;
if isKey(nidm_json, 'ReselsPerVoxelMap_atLocation')
    has_rpv = true;
    
    files.rpv = fullfile(outdir,['ReselsPerVoxel.nii' gz]);
    files.rpv_orig = nidm_json('ReselsPerVoxelMap_atLocation');
    img2nii(files.rpv_orig, files.rpv);
end

%-Analysis mask image (as NIfTI)
%--------------------------------------------------------------------------
files.mask_orig = nidm_json('MaskMap_atLocation');
files.mask = fullfile(outdir,['Mask.nii' gz]);
img2nii(files.mask_orig, files.mask);

%-Grand mean image (as NIfTI)
%--------------------------------------------------------------------------
files.grandmean = fullfile(outdir, ['GrandMean.nii' gz]);
gm_map = nidm_json('GrandMeanMap_atLocation');
img2nii(gm_map, files.grandmean);
gunzip(files.grandmean)
gunzip(files.mask)
grandMeanMedian = spm_summarise(strrep(files.grandmean, gz, ''),strrep(files.mask, gz, ''),@median);
spm_unlink(strrep(files.grandmean, '.gz', ''));
spm_unlink(strrep(files.mask, '.gz', ''));

%-Explicit mask image (as NIfTI)
%--------------------------------------------------------------------------
if isKey(nidm_json, 'CustomMap_atLocation')
    files.emask = fullfile(outdir,['CustomMask.nii' gz]);
    cmask_map = nidm_json('CustomMap_atLocation');
    img2nii(cmask_map, files.emask);
end

%-Clusters n-ary image (as NIfTI)
%--------------------------------------------------------------------------
if isKey(inference, 'ClusterLabelsMap_atLocation')
    has_clustlabelmap = true;
    files.clust = fullfile(outdir,['ClusterLabels.nii' gz]);
    clust_map = inference('ClusterLabelsMap_atLocation');
    img2nii(clust_map, files.clust);
else
    has_clustlabelmap = false;
end

%-Display mask images (as NIfTI)
%--------------------------------------------------------------------------
if isKey(inference, 'DisplayMaskMap_atLocation')
    files.dmask_orig = inference('DisplayMaskMap_atLocation');
    if ischar(files.dmask_orig)
        files.dmask_orig = {files.dmask_orig};
    end
    for i = 1:numel(files.dmask_orig)
        files.dmask{i} = fullfile(outdir,[sprintf('DisplayMask_%04d.nii',i) gz]);
        img2nii(files.dmask_orig{i}, files.dmask{i})
    end
end

%-SVC Mask (as NIfTI)
%--------------------------------------------------------------------------
% TODO

%-Search Space mask image (as NIfTI)
%--------------------------------------------------------------------------
files.searchspace = fullfile(outdir,['SearchSpaceMask.nii' gz]);
search_map = inference('SearchSpaceMaskMap_atLocation');
img2nii(search_map, files.searchspace)


%==========================================================================
%-                          D A T A   M O D E L
%==========================================================================

clear coordspace originalfile isHumanReadable

niifmt = {'image/nifti','xsd:string'};
isHumanReadable(false);

pp = spm_provenance;

%-Namespaces
%--------------------------------------------------------------------------
pp.add_namespace('nidm','http://purl.org/nidash/nidm#');
pp.add_namespace('niiri','http://iri.nidash.org/');
pp.add_namespace('spm','http://purl.org/nidash/spm#');
pp.add_namespace('neurolex','http://neurolex.org/wiki/');
pp.add_namespace('crypto','http://id.loc.gov/vocabulary/preservation/cryptographicHashFunctions#');
pp.add_namespace('dct','http://purl.org/dc/terms/');
pp.add_namespace('nfo','http://www.semanticdesktop.org/ontologies/2007/03/22/nfo#');
pp.add_namespace('dc','http://purl.org/dc/elements/1.1/');
pp.add_namespace('dctype','http://purl.org/dc/dcmitype/');
pp.add_namespace('obo','http://purl.obolibrary.org/obo/');

%-Provenance
%--------------------------------------------------------------------------
[V,R] = spm('Ver');

idResults = getid('niiri:spm_results_id',isHumanReadable);

if isKey(nidm_json, 'NIDMResults_version')
    NIDMversion = nidm_json('NIDMResults_version');
    % TODO should check version and say whether we are able to export 
else
    NIDMversion = '1.3.0';
end
pp.entity(idResults,{...
  'prov:type','prov:Bundle',...
  'prov:type',nidm_conv('nidm_NIDMResults',pp),...
  'prov:label','NIDM-Results',...
  nidm_conv('nidm_version',pp),{NIDMversion,'xsd:string'},...
  });

idExporter = getid('niiri:exporter_id',isHumanReadable);
softVersion = nidm_json('NIDMResultsExporter_softwareVersion');
pp.agent(idExporter,{...
    'prov:type',nidm_conv('nidm_spm_results_nidm',pp),...
    'prov:type','prov:SoftwareAgent',...
    'prov:label',{'spm_results_nidm','xsd:string'},...
    nidm_conv('nidm_softwareVersion',pp),{softVersion,'xsd:string'},...
    });

idExport = getid('niiri:export_id',isHumanReadable);
pp.activity(idExport,{...
    'prov:type',nidm_conv('nidm_NIDMResultsExport',pp),...
    'prov:label','NIDM-Results export',...
    });
pp.wasAssociatedWith(idExport, idExporter);
pp.wasGeneratedBy(idResults, idExport, now);

p = spm_provenance;
p.remove_namespace('prov');
p.remove_namespace('xsd');

coordsys = nidm_json('CoordinateSpace_inWorldCoordinateSystem');
coordsys = nidm_conv(coordsys,p);

%-Agent: SPM
%--------------------------------------------------------------------------
idSoftware = getid('niiri:software_id',isHumanReadable);
softwareVersion = nidm_json('NeuroimagingAnalysisSoftware_softwareVersion');

if isKey(nidm_json, 'NeuroimagingAnalysisSoftware_type')
    soft = nidm_json('NeuroimagingAnalysisSoftware_type');
    soft_label = nidm_json('NeuroimagingAnalysisSoftware_label');
end

p.agent(idSoftware,{...
    'prov:type',nidm_conv(soft,p),...
    'prov:type','prov:SoftwareAgent',...
    'prov:label',{soft_label,'xsd:string'},...
    nidm_conv('nidm_softwareVersion',p),{softwareVersion,'xsd:string'},...
    });

%-Entity: Coordinate Space
%--------------------------------------------------------------------------
units = nidm_json('nidm_CoordinateSpace/units');
gunzip(files.tspm)
excset_img = nifti(strrep(files.tspm, '.gz', ''));
spm_unlink(strrep(files.tspm, '.gz', ''))
id_data_coordspace = coordspace(p,excset_img.mat,excset_img.dat.dim,units,coordsys,1);

%-Agent: Scanner
%--------------------------------------------------------------------------
ImagingInstrument = nidm_json('Imaginginstrument_type');
switch ImagingInstrument
    case 'nlx_Magneticresonanceimagingscanner'
        ImagingInstrumentLabel = 'MRI Scanner';
    case 'nlx_Positronemissiontomographyscanner'
        ImagingInstrumentLabel = 'PET Scanner';
    case 'nlx_Singlephotonemissioncomputedtomographyscanner'
        ImagingInstrumentLabel = 'SPECT Scanner';     
    case 'nlx_Electroencephalographymachine'
        ImagingInstrumentLabel = 'EEG Machine';
    case 'nlx_Magnetoencephalographymachine'
        ImagingInstrumentLabel = 'MEG Machine';        
    otherwise
        error('Unknown modality.');
end

idScanner = getid('niiri:mr_scanner_id',isHumanReadable);
p.agent(idScanner,{...
    'prov:type',nidm_conv('nlx_Imaginginstrument',p),...
    'prov:type',nidm_conv(ImagingInstrument,p),...
    'prov:label',{ImagingInstrumentLabel,'xsd:string'},...
    });

%-Agent: Person
%--------------------------------------------------------------------------
if ~isKey(nidm_json, 'Groups')
    isgroup = false;
    
    idPerson = getid('niiri:subject_id',isHumanReadable);
    p.agent(idPerson,{...
        'prov:type','prov:Person',...
        'prov:label',{'Person','xsd:string'},...
        });
else
    isgroup = true;
    groups = nidm_json('Groups');
    
    group_names = groups.keys;
    
    %-Agent: Group
    %----------------------------------------------------------------------
    idGroup = cell(1,numel(group_names));
    for i=1:numel(group_names)
        idGroup{i} = getid(sprintf('niiri:group_id_%d',i),isHumanReadable);
        p.agent(idGroup{i},{...
            'prov:type',nidm_conv('obo_studygrouppopulation',p),...
            'prov:label',{sprintf('Group: %s',group_names{i}),'xsd:string'},...
            nidm_conv('nidm_groupName',p),{group_names{i},'xsd:string'},...
            nidm_conv('nidm_numberOfSubjects',p),{groups(group_names{i}),'xsd:int'},...
            });
    end
end

%-Entity: Image Data
%--------------------------------------------------------------------------
if nidm_json('Data_grandMeanScaling')
    target = nidm_json('Data_targetIntensity');
    extra_fields = {...
        nidm_conv('nidm_grandMeanScaling',p),{'true','xsd:boolean'},...
        nidm_conv('nidm_targetIntensity',p),{target,'xsd:float'},...
        };
else
    extra_fields = {...
        nidm_conv('nidm_grandMeanScaling',p),{'false','xsd:boolean'},...
        };
end
if isKey(nidm_json, 'Data_hasMRIProtocol')
    mri_protocol = nidm_json('Data_hasMRIProtocol');
    extra_fields = {extra_fields{:},...
        nidm_conv('nidm_hasMRIProtocol',p),nidm_conv(mri_protocol,p),...
        };
end
idData = getid('niiri:data_id',isHumanReadable);
p.entity(idData,{...
    'prov:type','prov:Collection',...
    'prov:type',nidm_conv('nidm_Data',p),...
    'prov:label',{'Data','xsd:string'},...
    extra_fields{:}});
p.wasAttributedTo(idData,idScanner);
if ~isgroup
    p.wasAttributedTo(idData,idPerson);
else
    for i=1:numel(group_names)
        p.wasAttributedTo(idData,idGroup{i});
    end
end

%-Entity: Drift Model
%--------------------------------------------------------------------------
if isKey(nidm_json, 'DesignMatrix_hasDriftModel')
    idDriftModel = getid('niiri:drift_model_id',isHumanReadable);
    
    drift_model = nidm_json('DesignMatrix_hasDriftModel');
    
    if strcmp(drift_model, 'spm_DiscreteCosineTransformbasisDriftModel')
        cut_off = nidm_json('DesignMatrix_SPMsDriftCutoffPeriod');
        extra_fields = {...
            nidm_conv('spm_SPMsDriftCutoffPeriod',p),...
            {cut_off,'xsd:float'}
        };
    end
    
    p.entity(idDriftModel,{...
        'prov:type',nidm_conv(drift_model,p),...
        'prov:label','SPM''s DCT Drift Model',...
        extra_fields{:};
        });
    extra_fields_drift = {nidm_conv('nidm_hasDriftModel',p),idDriftModel};
else
    extra_fields_drift = {};
end

%-Entity: Design Matrix
%--------------------------------------------------------------------------
idDesignMatrix = getid('niiri:design_matrix_id',isHumanReadable);
idDesignMatrixImage = getid('niiri:design_matrix_png_id',isHumanReadable);

extra_fields_basis_set = {};
if isKey(nidm_json, 'DesignMatrix_hasHRFBasis')
    hrf_bases = nidm_json('DesignMatrix_hasHRFBasis');
    for h = 1:numel(hrf_bases)
        extra_fields_basis_set(end+1:end+2) = ...
                {nidm_conv('nidm_hasHRFBasis',p),nidm_conv(hrf_bases{h},p)};
    end
end

p.entity(idDesignMatrix,{...
    'prov:type',nidm_conv('nidm_DesignMatrix',p),...
    'prov:location',{uri(spm_file(files.descsv,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.descsv,'filename'),'xsd:string'},...
    'dct:format',{'text/csv','xsd:string'},...
    'dc:description',idDesignMatrixImage,...
    'prov:label',{'Design Matrix','xsd:string'},...
    nidm_conv('nidm_regressorNames',p),{nidm_esc(reg_names),'xsd:string'},...
    extra_fields_drift{:},...
    extra_fields_basis_set{:}
    });

p.entity(idDesignMatrixImage,{...
    'prov:type','dctype:Image',...
    'prov:location',{uri(spm_file(files.desimg,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.desimg,'filename'),'xsd:string'},...
    'dct:format',{'image/png','xsd:string'},...
    });

%-Entity: Explicit Mask
%--------------------------------------------------------------------------
if isKey(nidm_json, 'CustomMap_atLocation')
    has_emask = true;
    
    emask_map = nidm_json('CustomMap_atLocation');
    emask_img = nifti(emask_map);
    
    if ~spm_check_orientations(struct('dim',{emask_img.dat.dim,stat_img.dat.dim},...
            'mat',{emask_img.dat.mat,stat_img.mat}),false)
        id_emask_coordspace = coordspace(p,SPM.xM.VM.mat,SPM.xM.VM.dim',...
            units,coordsys);
    else
        id_emask_coordspace = id_data_coordspace;
    end
    idMask2 = getid('niiri:mask_id_2',isHumanReadable);
    p.entity(idMask2,{...
        'prov:type',nidm_conv('nidm_MaskMap',p),... % CustomMaskMap
        'prov:location',{uri(spm_file(files.emask,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.emask,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Custom Mask','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_emask_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.emask,'cpath')),'xsd:string'},...
        });
    id = originalfile(p,files.emask,idMask2,nidm_conv('nidm_MaskMap',p)); % CustomMaskMap
    p.wasDerivedFrom(idMask2,id);
else
    has_emask = false;
end

%-Entity: Error Model
%--------------------------------------------------------------------------
err_dep = nidm_json('ErrorModel_hasErrorDependence');
err_var_hom = nidm_json('ErrorModel_errorVarianceHomogeneous');
if err_var_hom
    err_var_hom = 'true';
else
    err_var_hom = 'false';
end
extra_fields_NM = { ...
    nidm_conv('nidm_hasErrorDependence',p),nidm_conv(err_dep,p),...
    nidm_conv('nidm_errorVarianceHomogeneous',p),{err_var_hom,'xsd:boolean'}...
    };

if isKey(nidm_json, 'ErrorModel_varianceMapWiseDependence')
    err_var_dep = nidm_json('ErrorModel_varianceMapWiseDependence');
    extra_fields_NM(end+1:end+2) = { ...
        nidm_conv('nidm_varianceMapWiseDependence',p),nidm_conv(err_var_dep,p)
    };
end
if isKey(nidm_json, 'ErrorModel_dependenceMapWiseDependence')
    err_dep_dep = nidm_json('ErrorModel_dependenceMapWiseDependence');
    extra_fields_NM(end+1:end+2) = { ...
        nidm_conv('nidm_dependenceMapWiseDependence',p),nidm_conv(err_dep_dep,p)
    };
end

est_method = nidm_json('ModelParameterEstimation_withEstimationMethod');
extra_fields_PE = {
    nidm_conv('nidm_withEstimationMethod',p),nidm_conv(est_method,p),...
};

err_dist = nidm_json('ErrorModel_hasErrorDistribution');
if ~iscell(err_dist)
    err_dist = {err_dist};
end

for i = 1:numel(err_dist)
  extra_fields_NM(end+1:end+2) = { ...
      nidm_conv('nidm_hasErrorDistribution',p),nidm_conv(err_dist{i},p)
  };
end

idErrorModel = getid('niiri:error_model_id',isHumanReadable);
p.entity(idErrorModel,{...
    'prov:type',nidm_conv('nidm_ErrorModel',p),...
    extra_fields_NM{:}});

%-Activity: Model Parameters Estimation
%==========================================================================
idModelPE = getid('niiri:model_pe_id',isHumanReadable);
p.activity(idModelPE,{...
    'prov:type',nidm_conv('nidm_ModelParametersEstimation',p),...
    'prov:label','Model parameters estimation',...
    extra_fields_PE{:}});
p.wasAssociatedWith(idModelPE, idSoftware);
p.used(idModelPE, idDesignMatrix);
p.used(idModelPE, idData);
p.used(idModelPE, idErrorModel);
if has_emask
    p.used(idModelPE, idMask2);
end

%-Entity: Mask Map
%--------------------------------------------------------------------------
idMask1 = getid('niiri:mask_id_1',isHumanReadable);
p.entity(idMask1,{...
    'prov:type',nidm_conv('nidm_MaskMap',p),...
    'prov:location',{uri(spm_file(files.mask,'cpath')),'xsd:anyURI'},...
    nidm_conv('nidm_isUserDefined',p),{'false','xsd:boolean'},...
    'nfo:fileName',{spm_file(files.mask,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Mask','xsd:string'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.mask,'cpath')),'xsd:string'},...
    });
id = originalfile(p,files.mask_orig,idMask1,nidm_conv('nidm_MaskMap',p));
p.wasDerivedFrom(idMask1,id);
p.wasGeneratedBy(idMask1, idModelPE);

%-Entity: Grand Mean Map
%--------------------------------------------------------------------------
idGrandMean = getid('niiri:grand_mean_map_id',isHumanReadable);
p.entity(idGrandMean,{...
    'prov:type',nidm_conv('nidm_GrandMeanMap',p),...
    'prov:location',{uri(spm_file(files.grandmean,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.grandmean,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Grand Mean Map','xsd:string'},...
    nidm_conv('nidm_maskedMedian',p),{grandMeanMedian,'xsd:float'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.grandmean,'cpath')),'xsd:string'},...
    });
p.wasGeneratedBy(idGrandMean, idModelPE);

%-Entity: Parameter Estimate (Beta) Maps
%--------------------------------------------------------------------------
idBeta = cell(1,numel(files.beta));
for i=1:files.beta_orig.Count
    idBeta{i} = getid(sprintf('niiri:beta_map_id_%d',i),isHumanReadable);
    p.entity(idBeta{i},{...
        'prov:type',nidm_conv('nidm_ParameterEstimateMap',p),...
        'prov:location',{uri(files.beta{i}),'xsd:anyURI'}...
        'nfo:fileName',{spm_file(files.beta{i},'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{sprintf('Parameter Estimate Map %d',i),'xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(files.beta{i}),'xsd:string'},...        
    });
    id = originalfile(p,files.beta_orig(regressor_names{i}),idBeta{i},nidm_conv('nidm_ParameterEstimateMap',p));
    p.wasDerivedFrom(idBeta{i},id);
    p.wasGeneratedBy(idBeta{i}, idModelPE);
end

%-Entity: ResMS Map
%--------------------------------------------------------------------------
idResMS = getid('niiri:residual_mean_squares_map_id',isHumanReadable);
p.entity(idResMS,{...
    'prov:type',nidm_conv('nidm_ResidualMeanSquaresMap',p),...
    'prov:location',{uri(spm_file(files.rms,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.rms,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Residual Mean Squares Map','xsd:string'},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.rms,'cpath')),'xsd:string'},...
    });
id = originalfile(p,files.rms_orig,idResMS,nidm_conv('nidm_ResidualMeanSquaresMap',p));
p.wasDerivedFrom(idResMS,id);
p.wasGeneratedBy(idResMS, idModelPE);

%-Entity: RPV Map
%--------------------------------------------------------------------------
if has_rpv
    idRPV = getid('niiri:resels_per_voxel_map_id',isHumanReadable);
    p.entity(idRPV,{...
        'prov:type',nidm_conv('nidm_ReselsPerVoxelMap',p),...
        'prov:location',{uri(spm_file(files.rpv,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.rpv,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Resels per Voxel Map','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.rpv,'cpath')),'xsd:string'},...
        });
    id = originalfile(p,files.rpv_orig,idRPV,nidm_conv('nidm_ReselsPerVoxelMap',p));
    p.wasDerivedFrom(idRPV,id);
    p.wasGeneratedBy(idRPV, idModelPE);
end

%-Activity: Contrast Estimation
%==========================================================================

% if STAT == 'T', STAT = lower(STAT); end

contrast_names = contrasts.keys;
for c=1:contrasts.Count
    this_con_name = contrast_names{c};
    my_contrast = contrasts(this_con_name);
    
    if contrasts.Count == 1, postfix = '';
    else                    postfix = sprintf('_%d',c); end
    
    this_value = my_contrast('obo_contrastweightmatrix/prov:value');
    this_stat_type = my_contrast('StatisticMap_statisticType');
    
    if strcmp(this_stat_type, 'obo_tstatistic')
        this_stat = 'T';
    elseif strcmp(this_stat_type, 'obo_Fstatistic')
        this_stat = 'F';
    else
        warning('nidm:unknownStatType', ...
            ['Unrecognised stat type: ' this_stat_type])
        this_stat = 'U';
    end
    
    idConVec = getid(['niiri:contrast_id' postfix],isHumanReadable);
    p.entity(idConVec,{...
        'prov:type',nidm_conv('obo_contrastweightmatrix',p),...
        nidm_conv('nidm_statisticType',p),nidm_conv(this_stat_type,p),...
        nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
        'prov:label',{['Contrast: ' nidm_esc(this_con_name)],'xsd:string'},...
        'prov:value',{this_value,'xsd:string'},...
        });

    idConEst = getid(['niiri:contrast_estimation_id' postfix],isHumanReadable);
    p.activity(idConEst,{...
        'prov:type',nidm_conv('nidm_ContrastEstimation',p),...
        'prov:label',['Contrast estimation' strrep(postfix,'_',' ')],...
        });
    p.wasAssociatedWith(idConEst, idSoftware);
    p.used(idConEst, idMask1);
    p.used(idConEst, idResMS);
    p.used(idConEst, idDesignMatrix);
    p.used(idConEst,idConVec);
    for i=1:files.beta_orig.Count
        p.used(idConEst, idBeta{i});
    end
    
    errdof = my_contrast('StatisticMap_errorDegreesOfFreedom');
    idSPM{c} = getid(['niiri:statistic_map_id' postfix],isHumanReadable);
    p.entity(idSPM{c},{...
        'prov:type',nidm_conv('nidm_StatisticMap',p),...
        'prov:location',{uri(spm_file(files.spm{c},'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.spm{c},'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{[upper(this_stat) '-Statistic Map: ' nidm_esc(this_con_name)],'xsd:string'},...
        nidm_conv('nidm_statisticType',p),nidm_conv(this_stat_type,p),...
        nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
        nidm_conv('nidm_errorDegreesOfFreedom',p),{errdof,'xsd:float'},...
        nidm_conv('nidm_effectDegreesOfFreedom',p),{1,'xsd:float'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(files.spm{c}),'xsd:string'},...
        });
    id = originalfile(p,stat_map{c},idSPM{c},nidm_conv('nidm_StatisticMap',p));
    p.wasDerivedFrom(idSPM{c},id);
    p.wasGeneratedBy(idSPM{c},idConEst);
    
    if strcmp(this_stat_type, 'obo_tstatistic')
        idContrast = getid(['niiri:contrast_map_id' postfix],isHumanReadable);
        p.entity(idContrast,{...
            'prov:type',nidm_conv('nidm_ContrastMap',p),...
            'prov:location',{uri(spm_file(files.con{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.con{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{['Contrast Map: ' nidm_esc(this_con_name)],'xsd:string'},...
            nidm_conv('nidm_contrastName',p),{nidm_esc(this_con_name),'xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.con{c},'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.con_orig{c},idContrast,nidm_conv('nidm_ContrastMap',p));
        p.wasDerivedFrom(idContrast,id);
        p.wasGeneratedBy(idContrast,idConEst);
        
        idSE = getid(['niiri:contrast_standard_error_map_id' postfix],isHumanReadable);
        p.entity(idSE,{...
            'prov:type',nidm_conv('nidm_ContrastStandardErrorMap',p),...
            'prov:location',{uri(spm_file(files.conse{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.conse{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Contrast Standard Error Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.conse{c},'cpath')),'xsd:string'},...
            });
        p.wasGeneratedBy(idSE,idConEst);
    elseif strcmp(this_stat_type, 'obo_Fstatistic')
        idEffMS = getid(['niiri:contrast_explained_mean_square_map_id' postfix],isHumanReadable);
        p.entity(idEffMS,{...
            'prov:type',nidm_conv('nidm_ContrastExplainedMeanSquareMap',p),...
            'prov:location',{uri(spm_file(files.effms{c},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.effms{c},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Contrast Explained Mean Square Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
            'crypto:sha512',{sha512sum(spm_file(files.effms{c},'cpath')),'xsd:string'},...
            });
        p.wasGeneratedBy(idEffMS,idConEst);
    end
end

%-Entity: Height Threshold
%--------------------------------------------------------------------------
idHeightThresh = getid('niiri:height_threshold_id',isHumanReadable);

idHeightThresh3 = getid('niiri:height_threshold_id_3',isHumanReadable);

equivHeightThreshNames = {};
if isKey(inference, 'HeightThreshold_equivalentThreshold')
    equivHeightThreshNames = inference('HeightThreshold_equivalentThreshold').keys;
end

extra_fields_height = {};

if isKey(inference, 'HeightThreshold_equivalentThreshold')
    equivHThresholds = inference('HeightThreshold_equivalentThreshold');
    for i = 1:numel(equivHeightThreshNames)
        equivHThresh = equivHThresholds(equivHeightThreshNames{i});

        idEquivHThresh = getid('niiri:height_threshold_id_' + num2str(i),isHumanReadable);

        extra_fields_height(end+1:end+2) = {
            nidm_conv('nidm_equivalentThreshold',p),idEquivHThresh,...
        };

        p.entity(idEquivHThresh,{...
            'prov:type',nidm_conv('nidm_HeightThreshold',p),...
            'prov:type',nidm_conv(equivHThresh('HeightThreshold_type'), p),...
            ... %         'prov:label',{nidm_esc(equivHeightThreshNames{i}),'xsd:string'},...
            'prov:label',{'Height Threshold','xsd:string'},... 
            'prov:value',{equivHThresh('HeightThreshold_value'),'xsd:float'},...
        });
    end
end

height_thresh_type = inference('HeightThreshold_type');
height_thresh_value = inference('HeightThreshold_value');
switch(height_thresh_type)
    case 'obo_FWERadjustedpvalue'
        height_thresh_desc  = sprintf(': p<%f (FWE)',height_thresh_value);
    case 'nidm_PValueUncorrected'
        height_thresh_desc  = sprintf(': p<%f (unc.)',height_thresh_value);
    case 'obo_qvalue'
        height_thresh_desc  = sprintf(': p<%s (FDR)',height_thresh_value);
    case 'obo_statistic'
        height_thresh_desc  = sprintf(': %s>%f',stat, height_thresh_value);
    otherwise
        error(['Unrecognised threshold type: ' height_thresh_type])
end

p.entity(idHeightThresh,{...
    'prov:type',nidm_conv('nidm_HeightThreshold',p),...
    'prov:type',nidm_conv(height_thresh_type, p),...
    'prov:label',{nidm_esc(['Height Threshold' height_thresh_desc]),'xsd:string'},...
    'prov:value',{height_thresh_value,'xsd:float'},...
    extra_fields_height{:}
    });

%-Entity: Extent Threshold
%--------------------------------------------------------------------------
if spm_get_defaults('stats.rft.nonstat')
    warning('Non-stationary RFT results not handled yet.');
end

equivExtentThreshNames = {};

if isKey(inference, 'ExtentThreshold_equivalentThreshold')
    equivExtentThreshNames = inference('ExtentThreshold_equivalentThreshold').keys;
    equivEThresholds = inference('ExtentThreshold_equivalentThreshold');
end
extra_fields_extent = {};

for i = 1:numel(equivExtentThreshNames)
    equivEThresh = equivEThresholds(equivExtentThreshNames{i});
    
    idEquivEThresh = getid('niiri:extent_threshold_id_' + num2str(i),isHumanReadable);
    
    extra_fields_extent(end+1:end+2) = {
        nidm_conv('nidm_equivalentThreshold',p),idEquivEThresh,...
    };

    p.entity(idEquivEThresh,{...
        'prov:type',nidm_conv('nidm_ExtentThreshold',p),...
        'prov:type',nidm_conv(equivEThresh('ExtentThreshold_type'),p),...
        ... %         'prov:label',{nidm_esc(equivExtentThreshNames{i}),'xsd:string'},...
        'prov:label',{'Extent Threshold','xsd:string'},... 
        'prov:value',{equivEThresh('ExtentThreshold_value'),'xsd:float'},...
        });
end

extent_thresh_type = inference('ExtentThreshold_type');
switch(extent_thresh_type)
    case 'obo_FWERadjustedpvalue'
        extent_thresh_value = inference('ExtentThreshold_value');
        extent_thresh_desc  = sprintf(': p<%f (FWE)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'nidm_PValueUncorrected'
        extent_thresh_value = inference('ExtentThreshold_value');
        extent_thresh_desc  = sprintf(': p<%f (unc.)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'obo_qvalue'
        extent_thresh_value = inference('ExtentThreshold_value');
        extent_thresh_desc  = sprintf(': p<%s (FDR)',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            'prov:value',extent_thresh_value,...
        };
    case 'obo_statistic'
        extent_thresh_value = inference('ExtentThreshold_clusterSizeInVoxels');
        extent_thresh_desc  = sprintf(': k>=%d',extent_thresh_value);
        extra_fields_extent(end+1:end+2) = {
            nidm_conv('nidm_clusterSizeInVoxels',p),{extent_thresh_value,'xsd:int'},... 
        };
        if isKey(inference, 'ExtentThreshold_clusterSizeInResels')
            extra_fields_extent(end+1:end+2) = {
                nidm_conv('nidm_clusterSizeInResels',p),...
                {inference('ExtentThreshold_clusterSizeInResels'),'xsd:float'},...
            };
        end
end

idExtentThresh = getid('niiri:extent_threshold_id',isHumanReadable);
p.entity(idExtentThresh,{...
    'prov:type',nidm_conv('nidm_ExtentThreshold',p),...
    'prov:type',nidm_conv(extent_thresh_type,p),...
    'prov:label',{['Extent Threshold' extent_thresh_desc],'xsd:string'},...
    extra_fields_extent{:}
    });

%-Entity: Peak Definition Criteria
%--------------------------------------------------------------------------
maxNumberOfPeaksPerCluster = nidm_json('PeakDefinitionCriteria_maxNumberOfPeaksPerCluster');
minDistanceBetweenPeaks = nidm_json('PeakDefinitionCriteria_minDistanceBetweenPeaks');
idPeakDefCrit = getid('niiri:peak_definition_criteria_id',isHumanReadable);
p.entity(idPeakDefCrit,{...
    'prov:type',nidm_conv('nidm_PeakDefinitionCriteria',p),...
    'prov:label',{'Peak Definition Criteria','xsd:string'},...
    nidm_conv('nidm_maxNumberOfPeaksPerCluster',p),{maxNumberOfPeaksPerCluster,'xsd:int'},...
    nidm_conv('nidm_minDistanceBetweenPeaks',p),{minDistanceBetweenPeaks,'xsd:float'},...
    });

%-Entity: Cluster Definition Criteria
%--------------------------------------------------------------------------
clusterConnectivityCriterion = nidm_json('ClusterDefinitionCriteria_hasConnectivityCriterion'); % see spm_max.m
idClusterDefCrit = getid('niiri:cluster_definition_criteria_id',isHumanReadable);

switch(clusterConnectivityCriterion)
    case 'nidm_voxel18connected'
        connValue = 18;
    case 'nidm_voxel26connected'
        connValue = 18;
    case 'nidm_voxel9connected'
        connValue = 9;
    otherwise
        error('Unknown connectivity value')
end

p.entity(idClusterDefCrit,{...
    'prov:type',nidm_conv('nidm_ClusterDefinitionCriteria',p),...
    'prov:label',{sprintf('Cluster Connectivity Criterion: %d',connValue),'xsd:string'},...
    nidm_conv('nidm_hasConnectivityCriterion',p),nidm_conv(clusterConnectivityCriterion,p),...
    });


%-Activity: Inference
%==========================================================================
if numel(con_name) == 1
    st = {'prov:type',nidm_conv('nidm_Inference',p), ...
          nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference('Inference_hasAlternativeHypothesis'),p),...
          'prov:label','Inference'};
else
    switch(inference('Inference_type'))
        case 'nidm_ConjunctionInference'
            st = {'prov:type',nidm_conv('nidm_ConjunctionInference',p), ...
              nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference('Inference_hasAlternativeHypothesis'),p),...
              'prov:label','Conjunction Inference'};
        case 'spm_PartialConjunctionInference'
            partialConjDegree = inference('spm_PartialConjunctionInference/spm_partialConjunctionDegree');
            st = {'prov:type',nidm_conv('spm_PartialConjunctionInference',p), ...
              nidm_conv('nidm_hasAlternativeHypothesis',p),nidm_conv(inference('Inference_hasAlternativeHypothesis'),p),...
              'prov:label','Partial Conjunction Inference', ...
              nidm_conv('spm_partialConjunctionDegree',p),{partialConjDegree,'xsd:int'}};
        otherwise
            error('Unknown conjunction type.');
    end
end

idInference = getid('niiri:inference_id',isHumanReadable);
p.activity(idInference,st);
p.wasAssociatedWith(idInference, idSoftware);
p.used(idInference, idHeightThresh);
p.used(idInference, idExtentThresh);
for c=1:contrasts.Count
    if contrasts.Count == 1, postfix = '';
    else                    postfix = sprintf('_%d',c); end
    p.used(idInference, idSPM{c});
end
if has_rpv
    p.used(idInference, idRPV);
end
p.used(idInference, idMask1);
p.used(idInference, idPeakDefCrit);
p.used(idInference, idClusterDefCrit);

%-Entity: Display Mask Maps
%--------------------------------------------------------------------------
if isKey(inference, 'DisplayMaskMap_atLocation')
    for i=1:numel(files.dmask)
        gunzip(files.dmask{i});
        V = spm_vol(strrep(files.dmask{i}, '.gz', ''));
        spm_unlink(strrep(files.dmask{i}, '.gz', ''))
        
        gunzip(files.tspm);
        V_ex = spm_vol(strrep(files.tspm, '.gz', ''));
        spm_unlink(strrep(files.tspm, '.gz', ''))
        
        if ~spm_check_orientations(struct('dim',{V_ex.dim,V.dim},...
                'mat',{V_ex.mat,V.mat}),false)
            currCoordSpace = coordspace(p,V.mat,V.dim',units,coordsys);
        else
            currCoordSpace = id_data_coordspace;
        end

        if numel(files.dmask) == 1, postfix = '';
        else                    postfix = sprintf('_%d',i); end
        idDMask = getid(['niiri:display_mask_map_id' postfix],isHumanReadable);
        p.entity(idDMask,{...
            'prov:type',nidm_conv('nidm_DisplayMaskMap',p),...
            'prov:location',{uri(spm_file(files.dmask{i},'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.dmask{i},'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Display Mask Map','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),currCoordSpace,...
            'crypto:sha512',{sha512sum(spm_file(files.dmask{i},'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.dmask{i},idDMask,nidm_conv('nidm_DisplayMaskMap',p));
        p.wasDerivedFrom(idDMask,id);
        p.used(idInference, idDMask);
    end
end

%-Entity: SVC Mask Map
%--------------------------------------------------------------------------
if isKey(inference, 'SubVolumeMap_atLocation')
    % TODO deal with SVC
    if ~isempty(files.svcmask)
        V = spm_vol(files.svcmask);
        if ~spm_check_orientations(struct('dim',{xSPM.DIM',V.dim},...
                'mat',{xSPM.M,V.mat}),false)
            currCoordSpace = coordspace(p,V.mat,V.dim',units,coordsys);
        else
            currCoordSpace = id_data_coordspace;
        end
        idSVC = getid('niiri:sub_volume_id',isHumanReadable);
        p.entity(idSVC,{...
            'prov:type','nidm:SubVolumeMap',...
            'prov:location',{uri(spm_file(files.svcmask,'cpath')),'xsd:anyURI'},...
            'nfo:fileName',{spm_file(files.svcmask,'filename'),'xsd:string'},...
            'dct:format',niifmt,...
            'prov:label',{'Sub-volume','xsd:string'},...
            nidm_conv('nidm_inCoordinateSpace',p),currCoordSpace,...
            'crypto:sha512',{sha512sum(spm_file(files.svcmask,'cpath')),'xsd:string'},...
            });
        id = originalfile(p,files.svcmask,idSVC,'nidm:SubVolumeMap');
        p.wasDerivedFrom(idSVC,id);
        p.used(idInference, idSVC);
    end
end

%-Entity: Search Space
%--------------------------------------------------------------------------
rftstat = inference('SearchSpaceMaskMap_randomFieldStationarity');

if rftstat
    rftstat_str = 'true';
else
    rftstat_str = 'false';
end

% TODO checak if okay to have resels optional > maybe only for non param
extra_fields_searchspace = {};
has_resels = false;
if isKey(inference, 'SearchSpaceMaskMap_reselSizeInVoxels')
    has_resels = true;
    extra_fields_searchspace(end+1:end+8) = {
            nidm_conv('nidm_reselSizeInVoxels',p),{inference('SearchSpaceMaskMap_reselSizeInVoxels'),'xsd:float'},... 
            nidm_conv('nidm_searchVolumeInResels',p),{inference('SearchSpaceMaskMap_searchVolumeInResels'),'xsd:float'},...
            nidm_conv('nidm_noiseFWHMInVoxels',p),{inference('SearchSpaceMaskMap_noiseFWHMInVoxels'),'xsd:string'},...
            nidm_conv('nidm_noiseFWHMInUnits',p),{inference('SearchSpaceMaskMap_noiseFWHMInUnits'),'xsd:string'},...
        };
end

if isKey(inference, 'SearchSpaceMaskMap_heightCriticalThresholdFWE05')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_heightCriticalThresholdFWE05',p),{inference('SearchSpaceMaskMap_heightCriticalThresholdFWE05'),'xsd:float'},... 
        };
end
if isKey(inference, 'SearchSpaceMaskMap_heightCriticalThresholdFDR05')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_heightCriticalThresholdFDR05',p),{inference('SearchSpaceMaskMap_heightCriticalThresholdFDR05'),'xsd:float'},... 
        };
end
if isKey(inference, 'SearchSpaceMaskMap_expectedNumberOfVoxelsPerCluster')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_expectedNumberOfVoxelsPerCluster',p),{inference('SearchSpaceMaskMap_expectedNumberOfVoxelsPerCluster'),'xsd:float'},... 
        };
end
if isKey(inference, 'SearchSpaceMaskMap_expectedNumberOfClusters')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('nidm_expectedNumberOfClusters',p),{inference('SearchSpaceMaskMap_expectedNumberOfClusters'),'xsd:float'},... 
        };
end
if isKey(inference, 'SearchSpaceMaskMap_searchVolumeReselsGeometry')
    extra_fields_searchspace(end+1:end+2) = {
            nidm_conv('spm_searchVolumeReselsGeometry',p),{inference('SearchSpaceMaskMap_searchVolumeReselsGeometry'),'xsd:float'},... 
        };
end

idSearchSpace = getid('niiri:search_space_id',isHumanReadable);
search_space_attributes = {...
    'prov:type',nidm_conv('nidm_SearchSpaceMaskMap',p),...
    'prov:location',{uri(spm_file(files.searchspace,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.searchspace,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Search Space Mask Map','xsd:string'}...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    nidm_conv('nidm_searchVolumeInVoxels',p),{inference('SearchSpaceMaskMap_searchVolumeInVoxels'),'xsd:int'},...
    nidm_conv('nidm_searchVolumeInUnits',p),{inference('SearchSpaceMaskMap_searchVolumeInUnits'),'xsd:float'},...
    extra_fields_searchspace{:},...
    nidm_conv('nidm_randomFieldStationarity',p),{rftstat_str, 'xsd:boolean'},...
    'crypto:sha512',{sha512sum(spm_file(files.searchspace,'cpath')),'xsd:string'},...
    };
if isKey(inference, 'SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFWE05')
    search_space_attributes = [search_space_attributes, {...
        nidm_conv('spm_smallestSignificantClusterSizeInVoxelsFWE05',p),...
        {inference('SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFWE05'),'xsd:int'},...
        }];
end
if isKey(inference, 'SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFDR05')
    search_space_attributes = [search_space_attributes, {...
        nidm_conv('spm_smallestSignificantClusterSizeInVoxelsFDR05',p),...
        {inference('SearchSpaceMaskMap_smallestSignificantClusterSizeInVoxelsFDR05'),'xsd:int'},...
        }];
end
p.entity(idSearchSpace,search_space_attributes);
p.wasGeneratedBy(idSearchSpace, idInference);

%-Entity: Excursion Set
%--------------------------------------------------------------------------
extra_fields_excset = {};
if isKey(inference, 'ExcursionSetMap_numberOfSupraThresholdClusters')
    c = inference('ExcursionSetMap_numberOfSupraThresholdClusters');
    pc = inference('ExcursionSetMap_pValue');
    extra_fields_excset(end+1:end+4) = {
            nidm_conv('nidm_numberOfSupraThresholdClusters',p),{c,'xsd:int'},...
            nidm_conv('nidm_pValue',p),{pc,'xsd:float'},...
    };
end

if has_mip
    idMaximumIntensityProjection = getid('niiri:maximum_intensity_projection_id',isHumanReadable);
    extra_fields_excset(end+1:end+2) = {
        nidm_conv('nidm_hasMaximumIntensityProjection',p),idMaximumIntensityProjection,...
    };
end

if has_clustlabelmap
    idClusterLabelsMap = getid('niiri:cluster_label_map_id',isHumanReadable);
    extra_fields_excset(end+1:end+2) = {
        nidm_conv('nidm_hasClusterLabelsMap',p),idClusterLabelsMap,...
    };
end

idExcursionSet = getid('niiri:excursion_set_map_id',isHumanReadable);
p.entity(idExcursionSet,{...
    'prov:type',nidm_conv('nidm_ExcursionSetMap',p),...
    'prov:location',{uri(spm_file(files.tspm,'cpath')),'xsd:anyURI'},...
    'nfo:fileName',{spm_file(files.tspm,'filename'),'xsd:string'},...
    'dct:format',niifmt,...
    'prov:label',{'Excursion Set Map','xsd:string'},...
    extra_fields_excset{:},...
    nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
    'crypto:sha512',{sha512sum(spm_file(files.tspm,'cpath')),'xsd:string'},...
    });

% TODO: compute cluster label map if missing
if has_clustlabelmap
    p.entity(idClusterLabelsMap,{...
        'prov:type',nidm_conv('nidm_ClusterLabelsMap',p),...
        'prov:location',{uri(spm_file(files.clust,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.clust,'filename'),'xsd:string'},...
        'dct:format',niifmt,...
        'prov:label',{'Cluster Labels Map','xsd:string'},...
        nidm_conv('nidm_inCoordinateSpace',p),id_data_coordspace,...
        'crypto:sha512',{sha512sum(spm_file(files.clust,'cpath')),'xsd:string'},...
        });
end

if has_mip
    p.entity(idMaximumIntensityProjection,{...
        'prov:type','dctype:Image',...
        'prov:location',{uri(spm_file(files.mip,'cpath')),'xsd:anyURI'},...
        'nfo:fileName',{spm_file(files.mip,'filename'),'xsd:string'},...
        'dct:format',{'image/png','xsd:string'}...
        });
end
p.wasGeneratedBy(idExcursionSet, idInference); 

%-Entity: Clusters
%--------------------------------------------------------------------------
clusters = inference('Clusters');
clusters_names = inference('Clusters').keys;

% idx = find(~cellfun(@isempty,{TabDat.dat{:,5}}));
% idCluster = cell(1,numel(idx));
for i=1:numel(clusters_names)
    this_cluster = clusters(clusters_names{i});
    
    iClus = sprintf('%04d',i);
    idCluster{i} = getid(['niiri:supra_threshold_cluster_' iClus],isHumanReadable);
    
    extra_clust = {};
    if has_resels
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_clusterSizeInResels',p),{this_cluster('SupraThresholdCluster_clusterSizeInResels'),'xsd:float'},...
            };
    end
    if isKey(this_cluster, 'SupraThresholdCluster_pValueUncorrected')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_pValueUncorrected',p),{this_cluster('SupraThresholdCluster_pValueUncorrected'),'xsd:float'},...
            };
    end
    if isKey(this_cluster, 'SupraThresholdCluster_pValueFWER')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_pValueFWER',p),{this_cluster('SupraThresholdCluster_pValueFWER'),'xsd:float'},...
            };
    end
    if isKey(this_cluster, 'SupraThresholdCluster_qValueFDR')
        extra_clust(end+1:end+2) = {...
            nidm_conv('nidm_qValueFDR',p),{this_cluster('SupraThresholdCluster_qValueFDR'),'xsd:float'},...
            };
    end
    
    p.entity(idCluster{i},{...
        'prov:type',nidm_conv('nidm_SupraThresholdCluster',p),...
        'prov:label',{['Supra-Threshold Cluster: ' iClus],'xsd:string'},...
        nidm_conv('nidm_clusterSizeInVoxels',p),{this_cluster('SupraThresholdCluster_clusterSizeInVoxels'),'xsd:int'},...
        extra_clust{:},...
        nidm_conv('nidm_clusterLabelId',p),{num2str(i),'xsd:int'},...
        });
    p.wasDerivedFrom(idCluster{i}, idExcursionSet);
    
    %-Entity: Peaks
    %----------------------------------------------------------------------
    peaks = this_cluster('Peaks');
    peak_names = this_cluster('Peaks').keys;
    for j=1:numel(peak_names)
        my_peak = peaks(peak_names{j});
        
        iPeak  = peak_names{j};
        idPeak = getid(['niiri:peak_' iPeak],isHumanReadable);
        idCoordinate = getid(['niiri:coordinate_' iPeak],isHumanReadable);
        
        extra_peak = {};
        if isKey(my_peak, 'Peak_pValueUncorrected')
            extra_peak(end+1:end+4) = {...
                nidm_conv('nidm_pValueUncorrected',p),{my_peak('Peak_pValueUncorrected'),'xsd:float'},...
                nidm_conv('nidm_equivalentZStatistic',p),{my_peak('Peak_equivalentZStatistic'),'xsd:float'},...
                };
        end
        if isKey(my_peak, 'Peak_pValueFWER')
            extra_peak(end+1:end+2) = {...
                nidm_conv('nidm_pValueFWER',p),{my_peak('Peak_pValueFWER'),'xsd:float'},...
                };
        end
        if isKey(my_peak, 'Peak_qValueFDR')
            extra_peak(end+1:end+2) = {...
                nidm_conv('nidm_qValueFDR',p),{my_peak('Peak_qValueFDR'),'xsd:float'},...
                };
        end

        p.entity(idPeak,{...
            'prov:type',nidm_conv('nidm_Peak',p),...
            'prov:label',{['Peak: ' iPeak],'xsd:string'},...
            'prov:location',idCoordinate,...
            'prov:value',{my_peak('Peak_value'),'xsd:float'},...
            extra_peak{:},...
            });

        p.entity(idCoordinate,{...
            'prov:type','prov:Location',...
            'prov:type',nidm_conv('nidm_Coordinate',p),...
            'prov:label',{['Coordinate: ' iPeak],'xsd:string'},...
            nidm_conv('nidm_coordinateVector',p),{my_peak('Coordinate_coordinateVector'),'xsd:string'},...
            });

        p.wasDerivedFrom(idPeak, idCluster{i});
    end
end


pp.bundle(idResults,p);

%==========================================================================
%-                  P R O V   S E R I A L I Z A T I O N
%==========================================================================
%serialize(pp,fullfile(outdir,'nidm.provn'));
serialize(pp,fullfile(outdir,'nidm.ttl'));
try, serialize(pp,fullfile(outdir,'nidm.jsonld')); end
%serialize(pp,fullfile(outdir,'nidm.json'));
%serialize(pp,fullfile(outdir,'nidm.pdf'));

i = 1;
while true
    nidmfile = fullfile(spm_fileparts(outdir),sprintf('%s_%04d.nidm.zip',lower(soft_label),i));
    if spm_existfile(nidmfile), i = i + 1; else break; end
end
f = zip(nidmfile,'*',outdir);
for i=1:numel(f)
    spm_unlink(fullfile(outdir,f{i}));
end
rmdir(outdir);

prov = pp;


%==========================================================================
% function str = html_esc(str)
%==========================================================================
function str = html_esc(str)
%-Escape
% See http://www.w3.org/TR/html4/charset.html#h-5.3.2
str = strrep(str,'&','&amp;');
str = strrep(str,'<','&lt;');
str = strrep(str,'>','&gt;');
str = strrep(str,'"','&quot;');


%==========================================================================
% function u = uri(u)
%==========================================================================
function u = uri(u)
%-File URI scheme
%if ispc, s='/'; else s=''; end
%u = ['file://' s strrep(spm_file(u,'cpath'),'\','/')];
e = ' ';
for i=1:length(e)
    u = strrep(u,e(i),['%' dec2hex(e(i))]);
end
u = spm_file(u,'filename');


%==========================================================================
% function checksum = sha512sum(file)
%==========================================================================
function checksum = sha512sum(file)
md   = java.security.MessageDigest.getInstance('SHA-512');
file = spm_file(file,'cpath');
fid  = fopen(file,'rb');
if fid == -1, error('Cannot open "%s".',file); end
md.update(fread(fid,Inf,'*uint8'));
fclose(fid);
checksum = typecast(md.digest,'uint8');
checksum = lower(reshape(dec2hex(checksum)',1,[]));


%==========================================================================
% function checksum = md5sum(data)
%==========================================================================
function checksum = md5sum(data)
if ~nargin
    data = char(java.util.UUID.randomUUID);
end
md   = java.security.MessageDigest.getInstance('MD5');
if ischar(data)
    md.update(uint8(data));
else
    md.update(typecast(data,'uint8'));
end
checksum = typecast(md.digest,'uint8');
checksum = lower(reshape(dec2hex(checksum)',1,[]));


%==========================================================================
% function img2nii(img,nii,xSPM)
%==========================================================================
function img2nii(img,nii,xSPM)

% If input and output are nii.gz then use a simple copy
if strcmp(spm_file(img, 'ext'), 'gz') && strcmp(spm_file(nii, 'ext'), 'gz')
    copyfile(img, nii)
else
    if nargin == 2, xSPM = struct; end
    if ~isfield(xSPM,'STAT'), xSPM.STAT = ''; end
    if ~isfield(xSPM,'fcn'), xSPM.fcn = @(x) x; end
    if nargin == 1, nii = spm_file(img,'ext','.nii'); end
    gz = strcmp(spm_file(nii,'ext'),'gz');
    if gz, nii = spm_file(nii,'ext',''); end
    ni     = nifti(img);
    no     = nifti;
    no.dat = file_array(nii,...
                        ni.dat.dim,...
                        ni.dat.dtype,...
                        0,...
                        ni.dat.scl_slope,...
                        ni.dat.scl_inter);
    no.mat  = ni.mat;
    no.mat_intent = ni.mat_intent;
    no.mat0 = ni.mat0;
    no.mat0_intent = ni.mat0_intent;
    no.descrip = ni.descrip;
    switch xSPM.STAT
        case 'T'
            no.intent.name  = ['spm' xSPM.STATstr];
            no.intent.code  = 3;
            no.intent.param = xSPM.df(2);
        case 'F'
            no.intent.name  = ['spm' xSPM.STATstr];
            no.intent.code  = 4;
            no.intent.param = xSPM.df;
        case 'con'
            no.intent.name  = 'SPM contrast';
            no.intent.code  = 1001;
    end
    create(no);
    no.dat(:,:,:) = xSPM.fcn(ni.dat(:,:,:));
    if gz
        gzip(nii);
        spm_unlink(nii);
    end
end


%==========================================================================
% function make_ROI(fname,DIM,M,xY)
%==========================================================================
function make_ROI(fname,DIM,M,xY)
gz = strcmp(spm_file(fname,'ext'),'gz');
if gz, fname = spm_file(fname,'ext',''); end
R = struct(...
    'fname',  fname,...
    'dim',    DIM,...
    'dt',     [spm_type('uint8'), spm_platform('bigend')],...
    'mat',    M,...
    'pinfo',  [1,0,0]',...
    'descrip','ROI');
Q    = zeros(DIM);
[xY, XYZmm, j] = spm_ROI(xY, struct('dim',DIM,'mat',M));
Q(j) = 1;
R    = spm_write_vol(R,Q);
if gz
    gzip(R.fname);
    spm_unlink(R.fname);
end


%==========================================================================
% function id = coordspace(p,M,DIM,units,coordsys,idx)
%==========================================================================
function id = coordspace(p,M,DIM,units,coordsys,idx)
persistent index
if nargin == 6
    index = idx;
else
    if isempty(index)
        index = 1;
    else
        index = index + 1;
    end
end
% Convert from first voxel at [1,1,1] to first voxel at [0,0,0]
v2wm = M * [eye(4,3) [1 1 1 1]'];
M    = M(1:3,1:3);
id = getid(['niiri:coordinate_space_id_' num2str(index)],isHumanReadable);
p.entity(id,{...
    'prov:type',nidm_conv('nidm_CoordinateSpace',p),...
    'prov:label',{['Coordinate space ' num2str(index)],'xsd:string'},...
    nidm_conv('nidm_voxelToWorldMapping',p),{v2wm,'xsd:string'},...
    nidm_conv('nidm_voxelUnits',p),{units,'xsd:string'},...
    nidm_conv('nidm_voxelSize',p),{sqrt(diag(M'*M))','xsd:string'},...
    nidm_conv('nidm_inWorldCoordinateSystem',p),coordsys,...
    nidm_conv('nidm_numberOfDimensions',p),{numel(DIM),'xsd:int'},...
    nidm_conv('nidm_dimensionsInVoxels',p),{DIM,'xsd:string'}
    });

%==========================================================================
% function id = originalfile(p,file,idx,typ)
%==========================================================================
function id = originalfile(p,file,idx,typ)
id = getid([idx '_der'],isHumanReadable);
p.entity(id,{...
    'prov:type',typ,...
    'nfo:fileName',{spm_file(file,'filename'),'xsd:string'},...
    'dct:format',{'image/nifti','xsd:string'},...
    'crypto:sha512',{sha512sum(spm_file(file,'cpath')),'xsd:string'},...
    });

%==========================================================================
% function id = getid(id,humanReadable,checksum)
%==========================================================================
function id = getid(id,humanReadable,checksum)
if ~humanReadable
    if nargin == 2
        id = md5sum;
    else
        id = md5sum(checksum);
    end
    id = ['niiri:' id];
end

%==========================================================================
% function i = isHumanReadable(i)
%==========================================================================
function i = isHumanReadable(i)
persistent isHR
if nargin, isHR = i; end
if isempty(isHR), error('Default not set.'); end
i = isHR;

%==========================================================================
% function out = nidm_conv(in,p)
%==========================================================================
function out = nidm_conv(in,p)
persistent C
if isempty(C), C = nidm_constants; end

i = find(ismember(C(:,2),in));
if ~isempty(i)
    out = [C{i,2} ':'];
    if nargin == 2
        prefix = '';
        qname = C{i,1};
        j = find(qname == ':');
        if ~isempty(j)
            prefix = qname(1:j(end)-1);
            qname = qname(j(end)+1:end);
        end
        % should instead use ns = p.get_namespace;
        switch prefix
            case 'nidm'
                url = 'http://purl.org/nidash/nidm#';
            case 'spm'
                url = 'http://purl.org/nidash/spm#';
            case 'obo'
                url = 'http://purl.obolibrary.org/obo/';
            case 'nlx'
                url = 'http://uri.neuinfo.org/nif/nifstd/';
            case 'src'
                url = 'http://scicrunch.org/resolver/';
            otherwise
                warning('Unknown prefix "%s".',prefix);
                url = '';
        end
        p.add_namespace(C{i,2},[url qname]);
    end
else
    warning('Unknown element ''%s''.',in);
    out = in;
end

%==========================================================================
% function S = nidm_esc(S)
%==========================================================================
function S = nidm_esc(S)
S = strrep(S, sprintf('\n'), '\n');

%==========================================================================
% function nidm_store_constants
%==========================================================================
function nidm_store_constants
urlwrite('https://raw.githubusercontent.com/incf-nidash/nidm/master/nidm/nidm-results/terms/prefixes.csv','prefixes.csv');
C = reshape(textread('prefixes.csv','%s','delimiter',',','headerlines',1),2,[])';
fprintf('C = {...\n');
for i=1:size(C,1)
    fprintf('''%s'', ''%s'';...\n',C{i,1},strrep(C{i,2},':',''));
end
fprintf('};\n');

%==========================================================================
% function C = nidm_constants
%==========================================================================
function C = nidm_constants
% automatically generated by nidm_store_constants
C = {...
'obo:BFO_0000179', 'obo_BFOOWLspecificationlabel';...
'obo:BFO_0000180', 'obo_BFOCLIFspecificationlabel';...
'obo:IAO_0000002', 'obo_exampletobeeventuallyremoved';...
'obo:IAO_0000111', 'obo_editorpreferredterm';...
'obo:IAO_0000111', 'obo_editorpreferredterm';...
'obo:IAO_0000111', 'obo_editorpreferredterm';...
'obo:IAO_0000112', 'obo_exampleofusage';...
'obo:IAO_0000114', 'obo_hascurationstatus';...
'obo:IAO_0000115', 'obo_definition';...
'obo:IAO_0000115', 'obo_definition';...
'obo:IAO_0000115', 'obo_definition';...
'obo:IAO_0000115', 'obo_definition';...
'obo:IAO_0000116', 'obo_editornote';...
'obo:IAO_0000117', 'obo_termeditor';...
'obo:IAO_0000118', 'obo_alternativeterm';...
'obo:IAO_0000119', 'obo_definitionsource';...
'obo:IAO_0000120', 'obo_metadatacomplete';...
'obo:IAO_0000121', 'obo_organizationalterm';...
'obo:IAO_0000122', 'obo_readyforrelease';...
'obo:IAO_0000123', 'obo_metadataincomplete';...
'obo:IAO_0000124', 'obo_uncurated';...
'obo:IAO_0000125', 'obo_pendingfinalvetting';...
'obo:IAO_0000136', 'obo_isabout';...
'obo:IAO_0000232', 'obo_curatornote';...
'obo:IAO_0000412', 'obo_importedfrom';...
'obo:IAO_0000423', 'obo_tobereplacedwithexternalontologyterm';...
'obo:IAO_0000428', 'obo_requiresdiscussion';...
'obo:IAO_0000600', 'obo_elucidation';...
'obo:OBI_0000251', 'obo_cluster';...
'obo:OBI_0001265', 'obo_FWERadjustedpvalue';...
'obo:OBI_0001442', 'obo_qvalue';...
'obo:STATO_0000030', 'obo_ChiSquaredstatistic';...
'obo:STATO_0000039', 'obo_statistic';...
'obo:STATO_0000051', 'obo_Poissondistribution';...
'obo:STATO_0000067', 'obo_continuousprobabilitydistribution';...
'obo:STATO_0000117', 'obo_discreteprobabilitydistribution';...
'obo:STATO_0000119', 'obo_modelparameterestimation';...
'obo:STATO_0000129', 'obo_hasvalue';...
'obo:STATO_0000176', 'obo_tstatistic';...
'obo:STATO_0000193', 'obo_studygrouppopulation';...
'obo:STATO_0000225', 'obo_probabilitydistribution';...
'obo:STATO_0000227', 'obo_normaldistribution';...
'obo:STATO_0000276', 'obo_binomialdistribution';...
'obo:STATO_0000282', 'obo_Fstatistic';...
'obo:STATO_0000323', 'obo_contrastweightmatrix';...
'obo:STATO_0000346', 'obo_covariancestructure';...
'obo:STATO_0000357', 'obo_Toeplitzcovariancestructure';...
'obo:STATO_0000362', 'obo_compoundsymmetrycovariancestructure';...
'obo:STATO_0000370', 'obo_ordinaryleastsquaresestimation';...
'obo:STATO_0000371', 'obo_weightedleastsquaresestimation';...
'obo:STATO_0000372', 'obo_generalizedleastsquaresestimation';...
'obo:STATO_0000373', 'obo_iterativelyreweightedleastsquaresestimation';...
'obo:STATO_0000374', 'obo_feasiblegeneralizedleastsquaresestimation';...
'obo:STATO_0000376', 'obo_Zstatistic';...
'obo:STATO_0000405', 'obo_unstructuredcovariancestructure';...
'iao:iao.owl', 'iao_IAORelease20150223';...
'dc:contributor', 'dc_Contributor';...
'dc:creator', 'dc_Creator';...
'dc:date', 'dc_Date';...
'dc:date', 'dc_Date';...
'dc:description', 'dc_Description';...
'dc:title', 'dc_Title';...
'fsl:FSL_0000001', 'fsl_FSLsGammaDifferenceHRF';...
'fsl:FSL_0000002', 'fsl_GaussianRunningLineDriftModel';...
'fsl:FSL_0000003', 'fsl_FSLsTemporalDerivative';...
'fsl:FSL_0000004', 'fsl_driftCutoffPeriod';...
'fsl:FSL_0000005', 'fsl_featVersion';...
'nidm:NIDM_0000001', 'nidm_ContrastEstimation';...
'nidm:NIDM_0000002', 'nidm_ContrastMap';...
'nidm:NIDM_0000004', 'nidm_BinaryMap';...
'nidm:NIDM_0000007', 'nidm_ClusterDefinitionCriteria';...
'nidm:NIDM_0000008', 'nidm_ClusterLabelsMap';...
'nidm:NIDM_0000009', 'nidm_Colin27CoordinateSystem';...
'nidm:NIDM_0000011', 'nidm_ConjunctionInference';...
'nidm:NIDM_0000012', 'nidm_ConnectivityCriterion';...
'nidm:NIDM_0000013', 'nidm_ContrastStandardErrorMap';...
'nidm:NIDM_0000015', 'nidm_Coordinate';...
'nidm:NIDM_0000016', 'nidm_CoordinateSpace';...
'nidm:NIDM_0000017', 'nidm_CustomCoordinateSystem';...
'nidm:NIDM_0000019', 'nidm_DesignMatrix';...
'nidm:NIDM_0000020', 'nidm_DisplayMaskMap';...
'nidm:NIDM_0000021', 'nidm_regressorNames';...
'nidm:NIDM_0000023', 'nidm_ErrorModel';...
'nidm:NIDM_0000024', 'nidm_ExchangeableError';...
'nidm:NIDM_0000025', 'nidm_ExcursionSetMap';...
'nidm:NIDM_0000026', 'nidm_ExtentThreshold';...
'nidm:NIDM_0000027', 'nidm_NIDMResults';...
'nidm:NIDM_0000028', 'nidm_FiniteImpulseResponseBasisSet';...
'nidm:NIDM_0000029', 'nidm_GammaDifferenceHRF';...
'nidm:NIDM_0000030', 'nidm_GammaBasisSet';...
'nidm:NIDM_0000031', 'nidm_GammaHRF';...
'nidm:NIDM_0000033', 'nidm_GrandMeanMap';...
'nidm:NIDM_0000034', 'nidm_HeightThreshold';...
'nidm:NIDM_0000035', 'nidm_HemodynamicResponseFunction';...
'nidm:NIDM_0000036', 'nidm_ConvolutionBasisSet';...
'nidm:NIDM_0000037', 'nidm_HemodynamicResponseFunctionDerivative';...
'nidm:NIDM_0000038', 'nidm_Icbm452AirCoordinateSystem';...
'nidm:NIDM_0000039', 'nidm_Icbm452Warp5CoordinateSystem';...
'nidm:NIDM_0000040', 'nidm_IcbmMni152LinearCoordinateSystem';...
'nidm:NIDM_0000041', 'nidm_IcbmMni152NonLinear2009aAsymmetricCoordinateSystem';...
'nidm:NIDM_0000042', 'nidm_IcbmMni152NonLinear2009aSymmetricCoordinateSystem';...
'nidm:NIDM_0000043', 'nidm_IcbmMni152NonLinear2009bAsymmetricCoordinateSystem';...
'nidm:NIDM_0000044', 'nidm_IcbmMni152NonLinear2009bSymmetricCoordinateSystem';...
'nidm:NIDM_0000045', 'nidm_IcbmMni152NonLinear2009cAsymmetricCoordinateSystem';...
'nidm:NIDM_0000046', 'nidm_IcbmMni152NonLinear2009cSymmetricCoordinateSystem';...
'nidm:NIDM_0000047', 'nidm_IcbmMni152NonLinear6thGenerationCoordinateSystem';...
'nidm:NIDM_0000048', 'nidm_IndependentError';...
'nidm:NIDM_0000049', 'nidm_Inference';...
'nidm:NIDM_0000050', 'nidm_Ixi549CoordinateSystem';...
'nidm:NIDM_0000051', 'nidm_MNICoordinateSystem';...
'nidm:NIDM_0000052', 'nidm_Map';...
'nidm:NIDM_0000053', 'nidm_MapHeader';...
'nidm:NIDM_0000054', 'nidm_MaskMap';...
'nidm:NIDM_0000055', 'nidm_Mni305CoordinateSystem';...
'nidm:NIDM_0000056', 'nidm_ModelParametersEstimation';...
'nidm:NIDM_0000057', 'nidm_NIDMObjectModel';...
'nidm:NIDM_0000059', 'nidm_NonParametricSymmetricDistribution';...
'nidm:NIDM_0000060', 'nidm_OneTailedTest';...
'nidm:NIDM_0000061', 'nidm_ParameterEstimateMap';...
'nidm:NIDM_0000062', 'nidm_Peak';...
'nidm:NIDM_0000063', 'nidm_PeakDefinitionCriteria';...
'nidm:NIDM_0000064', 'nidm_PixelConnectivityCriterion';...
'nidm:NIDM_0000066', 'nidm_ResidualMeanSquaresMap';...
'nidm:NIDM_0000067', 'nidm_CustomBasisSet';...
'nidm:NIDM_0000068', 'nidm_SearchSpaceMaskMap';...
'nidm:NIDM_0000069', 'nidm_FourierBasisSet';...
'nidm:NIDM_0000070', 'nidm_SupraThresholdCluster';...
'nidm:NIDM_0000071', 'nidm_ErrorParameterMapWiseDependence';...
'nidm:NIDM_0000072', 'nidm_ConstantParameter';...
'nidm:NIDM_0000073', 'nidm_IndependentParameter';...
'nidm:NIDM_0000074', 'nidm_RegularizedParameter';...
'nidm:NIDM_0000075', 'nidm_StandardizedCoordinateSystem';...
'nidm:NIDM_0000076', 'nidm_StatisticMap';...
'nidm:NIDM_0000077', 'nidm_SubjectCoordinateSystem';...
'nidm:NIDM_0000078', 'nidm_TalairachCoordinateSystem';...
'nidm:NIDM_0000079', 'nidm_TwoTailedTest';...
'nidm:NIDM_0000080', 'nidm_VoxelConnectivityCriterion';...
'nidm:NIDM_0000081', 'nidm_WorldCoordinateSystem';...
'nidm:NIDM_0000082', 'nidm_clusterLabelId';...
'nidm:NIDM_0000083', 'nidm_clusterSizeInVertices';...
'nidm:NIDM_0000084', 'nidm_clusterSizeInVoxels';...
'nidm:NIDM_0000085', 'nidm_contrastName';...
'nidm:NIDM_0000086', 'nidm_coordinateVector';...
'nidm:NIDM_0000087', 'nidm_DriftModel';...
'nidm:NIDM_0000088', 'nidm_hasDriftModel';...
'nidm:NIDM_0000089', 'nidm_dependenceMapWiseDependence';...
'nidm:NIDM_0000090', 'nidm_dimensionsInVoxels';...
'nidm:NIDM_0000091', 'nidm_effectDegreesOfFreedom';...
'nidm:NIDM_0000092', 'nidm_equivalentZStatistic';...
'nidm:NIDM_0000093', 'nidm_errorDegreesOfFreedom';...
'nidm:NIDM_0000094', 'nidm_errorVarianceHomogeneous';...
'nidm:NIDM_0000096', 'nidm_grandMeanScaling';...
'nidm:NIDM_0000097', 'nidm_hasAlternativeHypothesis';...
'nidm:NIDM_0000098', 'nidm_hasClusterLabelsMap';...
'nidm:NIDM_0000099', 'nidm_hasConnectivityCriterion';...
'nidm:NIDM_0000100', 'nidm_hasErrorDependence';...
'nidm:NIDM_0000101', 'nidm_hasErrorDistribution';...
'nidm:NIDM_0000102', 'nidm_hasHRFBasis';...
'nidm:NIDM_0000103', 'nidm_hasMapHeader';...
'nidm:NIDM_0000104', 'nidm_inCoordinateSpace';...
'nidm:NIDM_0000105', 'nidm_inWorldCoordinateSystem';...
'nidm:NIDM_0000106', 'nidm_isUserDefined';...
'nidm:NIDM_0000107', 'nidm_maskedMedian';...
'nidm:NIDM_0000108', 'nidm_maxNumberOfPeaksPerCluster';...
'nidm:NIDM_0000109', 'nidm_minDistanceBetweenPeaks';...
'nidm:NIDM_0000110', 'nidm_GaussianHRF';...
'nidm:NIDM_0000111', 'nidm_numberOfSupraThresholdClusters';...
'nidm:NIDM_0000112', 'nidm_numberOfDimensions';...
'nidm:NIDM_0000113', 'nidm_objectModel';...
'nidm:NIDM_0000114', 'nidm_pValue';...
'nidm:NIDM_0000115', 'nidm_pValueFWER';...
'nidm:NIDM_0000116', 'nidm_pValueUncorrected';...
'nidm:NIDM_0000117', 'nidm_pixel4connected';...
'nidm:NIDM_0000118', 'nidm_pixel8connected';...
'nidm:NIDM_0000119', 'nidm_qValueFDR';...
'nidm:NIDM_0000120', 'nidm_randomFieldStationarity';...
'nidm:NIDM_0000121', 'nidm_searchVolumeInVoxels';...
'nidm:NIDM_0000122', 'nidm_softwareVersion';...
'nidm:NIDM_0000123', 'nidm_statisticType';...
'nidm:NIDM_0000124', 'nidm_targetIntensity';...
'nidm:NIDM_0000126', 'nidm_varianceMapWiseDependence';...
'nidm:NIDM_0000127', 'nidm_version';...
'nidm:NIDM_0000128', 'nidm_voxel18connected';...
'nidm:NIDM_0000129', 'nidm_voxel26connected';...
'nidm:NIDM_0000130', 'nidm_voxel6connected';...
'nidm:NIDM_0000131', 'nidm_voxelSize';...
'nidm:NIDM_0000132', 'nidm_voxelToWorldMapping';...
'nidm:NIDM_0000133', 'nidm_voxelUnits';...
'nidm:NIDM_0000134', 'nidm_withEstimationMethod';...
'nidm:NIDM_0000135', 'nidm_ContrastVarianceMap';...
'nidm:NIDM_0000136', 'nidm_searchVolumeInUnits';...
'nidm:NIDM_0000137', 'nidm_searchVolumeInVertices';...
'nidm:NIDM_0000138', 'nidm_hasMaximumIntensityProjection';...
'nidm:NIDM_0000139', 'nidm_coordinateVectorInVoxels';...
'nidm:NIDM_0000140', 'nidm_ClusterCenterOfGravity';...
'nidm:NIDM_0000141', 'nidm_expectedNumberOfClusters';...
'nidm:NIDM_0000142', 'nidm_expectedNumberOfVerticesPerCluster';...
'nidm:NIDM_0000143', 'nidm_expectedNumberOfVoxelsPerCluster';...
'nidm:NIDM_0000144', 'nidm_ReselsPerVoxelMap';...
'nidm:NIDM_0000145', 'nidm_noiseRoughnessInVoxels';...
'nidm:NIDM_0000146', 'nidm_heightCriticalThresholdFDR05';...
'nidm:NIDM_0000147', 'nidm_heightCriticalThresholdFWE05';...
'nidm:NIDM_0000148', 'nidm_reselSizeInVoxels';...
'nidm:NIDM_0000149', 'nidm_searchVolumeInResels';...
'nidm:NIDM_0000150', 'nidm_LinearSplineBasisSet';...
'nidm:NIDM_0000151', 'nidm_SineBasisSet';...
'nidm:NIDM_0000156', 'nidm_clusterSizeInResels';...
'nidm:NIDM_0000157', 'nidm_noiseFWHMInUnits';...
'nidm:NIDM_0000158', 'nidm_noiseFWHMInVertices';...
'nidm:NIDM_0000159', 'nidm_noiseFWHMInVoxels';...
'nidm:NIDM_0000160', 'nidm_PValueUncorrected';...
'nidm:NIDM_0000161', 'nidm_equivalentThreshold';...
'nidm:NIDM_0000162', 'nidm_Threshold';...
'nidm:NIDM_0000163', 'nidm_ContrastExplainedMeanSquareMap';...
'nidm:NIDM_0000164', 'nidm_NeuroimagingAnalysisSoftware';...
'nidm:NIDM_0000165', 'nidm_NIDMResultsExporter';...
'nidm:NIDM_0000166', 'nidm_NIDMResultsExport';...
'nidm:NIDM_0000167', 'nidm_nidmfsl';...
'nidm:NIDM_0000168', 'nidm_spm_results_nidm';...
'nidm:NIDM_0000169', 'nidm_Data';...
'nidm:NIDM_0000170', 'nidm_groupName';...
'nidm:NIDM_0000171', 'nidm_numberOfSubjects';...
'nidm:NIDM_0000172', 'nidm_hasMRIProtocol';...
'spm:SPM_0000001', 'spm_SPMsDriftCutoffPeriod';...
'spm:SPM_0000002', 'spm_DiscreteCosineTransformbasisDriftModel';...
'spm:SPM_0000003', 'spm_SPMsDispersionDerivative';...
'spm:SPM_0000004', 'spm_SPMsCanonicalHRF';...
'spm:SPM_0000005', 'spm_PartialConjunctionInference';...
'spm:SPM_0000006', 'spm_SPMsTemporalDerivative';...
'spm:SPM_0000010', 'spm_searchVolumeReselsGeometry';...
'spm:SPM_0000011', 'spm_smallestSignificantClusterSizeInVerticesFDR05';...
'spm:SPM_0000012', 'spm_smallestSignificantClusterSizeInVerticesFWE05';...
'spm:SPM_0000013', 'spm_smallestSignificantClusterSizeInVoxelsFDR05';...
'spm:SPM_0000014', 'spm_smallestSignificantClusterSizeInVoxelsFWE05';...
'spm:SPM_0000015', 'spm_partialConjunctionDegree';...
'prv:PropertyReification', 'prv_PropertyReification';...
'prv:object_property', 'prv_hasobjectproperty';...
'prv:reification_class', 'prv_hasreificationclass';...
'prv:shortcut', 'prv_hasshortcut';...
'prv:shortcut_property', 'prv_hasshortcutproperty';...
'prv:subject_property', 'prv_hassubjectproperty';...
'src:SCR_002823', 'src_FSL';...
'src:SCR_007037', 'src_SPM';...
'src:SCR_002092', 'src_SnPM';...
'nlx:birnlex_2094', 'nlx_Imaginginstrument';...
'nlx:birnlex_2100', 'nlx_Magneticresonanceimagingscanner';...
'nlx:birnlex_2177', 'nlx_MRIprotocol';...
'nlx:birnlex_2250', 'nlx_FunctionalMRIprotocol';...
'nlx:birnlex_2251', 'nlx_StructuralMRIprotocol';...
'nlx:ixl_0050000', 'nlx_Positronemissiontomographyscanner';...
'nlx:ixl_0050001', 'nlx_Singlephotonemissioncomputedtomographyscanner';...
'nlx:ixl_0050002', 'nlx_Magnetoencephalographymachine';...
'nlx:ixl_0050003', 'nlx_Electroencephalographymachine';...
'nlx:ixl_0050004', 'nlx_AnatomicalMRIprotocol';...
'nlx:nlx_inv_20090249', 'nlx_Diffusionweightedimagingprotocol';...
};

